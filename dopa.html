<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D GLB Model Interaction Scene</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap");
      body {
        font-family: "Inter", sans-serif;
        margin: 0;
        overflow: hidden;
        background-color: #0d0d1a;
      }
      canvas {
        display: block;
        cursor: crosshair;
      }
      #interact-prompt {
        transition: opacity 0.3s ease-in-out;
        pointer-events: none;
      }
      #start-button {
        transition: all 0.3s ease;
      }
      #start-button:hover {
        transform: scale(1.05);
        background-color: #3b82f6;
      }
      #website-panel {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.8);
        width: 80vw;
        height: 80vh;
        background: white;
        border-radius: 1rem;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        z-index: 1000;
        opacity: 0;
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        display: none;
        flex-direction: column;
      }
      #website-panel.active {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
        display: flex;
      }
      #panel-close {
        transition: all 0.3s ease;
      }
      #panel-close:hover {
        background-color: #ef4444;
        transform: scale(1.1);
      }
    </style>
  </head>
  <body class="bg-[#0d0d1a]">
    <!-- Instructional Overlay -->
    <div
      id="info-overlay"
      class="fixed inset-0 flex flex-col items-center justify-center bg-black bg-opacity-90 text-white z-10"
    >
      <div
        class="p-8 bg-gray-900 bg-opacity-95 rounded-2xl shadow-2xl border border-sky-500/50 max-w-lg w-11/12 text-center"
      >
        <h1 class="text-4xl font-extrabold mb-4 text-sky-400">
          Ready to revisit Earth!
        </h1>
        <p class="text-xl mb-6 text-gray-300">Let's Relax!!!</p>
        <p class="text-sm text-gray-400 leading-relaxed space-y-2 mb-6">
          <span class="block"
            >Status:
            <span id="loading-status" class="text-yellow-400"
              >Initializing...</span
            ></span
          >
          <span class="block mt-4"
            >Movement:
            <span
              class="font-mono bg-gray-700 py-1 px-2 rounded-lg mx-1 text-yellow-300"
              >WASD</span
            ></span
          >
          <span class="block"
            >Jump:
            <span
              class="font-mono bg-gray-700 py-1 px-2 rounded-lg mx-1 text-yellow-300"
              >SPACE</span
            ></span
          >
          <span class="block"
            >Interact:
            <span
              class="font-mono bg-gray-700 py-1 px-2 rounded-lg mx-1 text-yellow-300"
              >E</span
            ></span
          >
          <span class="block"
            >Look:
            <span
              class="font-mono bg-gray-700 py-1 px-2 rounded-lg mx-1 text-yellow-300"
              >MOUSE</span
            ></span
          >
          <span class="block"
            >Exit:
            <span
              class="font-mono bg-gray-700 py-1 px-2 rounded-lg mx-1 text-yellow-300"
              >B</span
            ></span
          >
        </p>
        <button
          id="start-button"
          class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-8 rounded-lg text-lg transition-all duration-300"
        >
          CLICK TO START
        </button>
        <p id="user-id-display" class="mt-6 text-xs text-gray-500">
          Simulation Mode
        </p>
      </div>
    </div>

    <!-- Interaction Prompt -->
    <div
      id="interact-prompt"
      class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 p-4 bg-sky-800 bg-opacity-90 text-white rounded-lg shadow-xl font-bold text-lg hidden z-20"
    >
      Press [E] to Open DopaminoMeter!
    </div>

    <!-- Website Panel - SIMPLIFIED POSITIONING -->
    <div id="website-panel">
      <div
        class="bg-gray-800 px-4 py-3 rounded-t-2xl flex justify-between items-center"
      >
        <h3 class="text-white font-bold text-lg">Browser Panel</h3>
        <button
          id="panel-close"
          class="bg-red-500 hover:bg-red-600 text-white w-8 h-8 rounded-full flex items-center justify-center font-bold"
        >
          Ã—
        </button>
      </div>
      <iframe
        id="panel-frame"
        src="about:blank"
        class="flex-1 w-full rounded-b-2xl border-0"
        sandbox="allow-scripts allow-same-origin allow-forms allow-popups"
      ></iframe>
    </div>

    <!-- Main Canvas Container -->
    <div
      id="canvas-container"
      class="w-full h-full absolute top-0 left-0"
    ></div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>

    <script>
      // Configuration
      const MODEL_URL = "materials/city_park_at_sunset.glb";
      const SECOND_MODEL_URL = "materials/DM room .glb"; // Replace with your second model path
      const TARGET_WEBSITE = "survey.html";
      const B_KEY_TRANSITION_URL = "index.html"; // Replace with your desired URL

      // SECOND MODEL CONFIGURATION - EDIT THESE VALUES
      const SECOND_MODEL_POSITION = new THREE.Vector3(90, 0, 10); // Position: x, y, z
      const SECOND_MODEL_ROTATION = new THREE.Vector3(0, -Math.PI / 2, 0); // Rotation in radians: x, y, z
      const SECOND_MODEL_SCALE = new THREE.Vector3(7, 7, 7); // Scale: x, y, z

      // Interaction settings - MOVED TO SECOND MODEL
      const INTERACT_POSITION = SECOND_MODEL_POSITION.clone(); // Use second model position
      const INTERACT_RADIUS = 15.0;

      // Game settings
      const MOVEMENT_SPEED = 25.0;
      const GRAVITY = 50.0;
      const JUMP_VELOCITY = 12.0;
      const PLAYER_HEIGHT = 5;

      // Global variables
      let camera, scene, renderer, controls;
      let isModelLoaded = false;
      let isSecondModelLoaded = false;
      let isControlsEnabled = false;
      let isPanelOpen = false;
      let panelMesh = null;
      let isUnlockingForPanel = false;
      let secondModel = null;

      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      let canJump = false;
      let keyEPressed = false;

      let prevTime = performance.now();
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();

      function init() {
        console.log("Initializing 3D scene...");
        const container = document.getElementById("canvas-container");
        const statusDisplay = document.getElementById("loading-status");

        // Create camera - start position looking at the center
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, PLAYER_HEIGHT, 100);

        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 10, 300);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffcc, 1.0);
        directionalLight.position.set(50, 200, 100);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Create environment - ONLY FLOOR
        createGround();
        createCenterPanelScreen();

        // Load models
        loadModel(statusDisplay);
        loadSecondModel();

        // Setup controls
        setupControls();

        // Setup panel events
        setupPanel();

        // Event listeners
        window.addEventListener("resize", onWindowResize);

        // Start animation
        animate();

        console.log("Scene initialized successfully");
      }

      function createGround() {
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        groundGeometry.rotateX(-Math.PI / 2);
        const groundMaterial = new THREE.MeshPhongMaterial({
          color: 0x3a7d3a,
          shininess: 10,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.receiveShadow = true;
        scene.add(ground);
      }

      function createCenterPanelScreen() {
        // Create a LARGE screen in the CENTER of the room
        const screenGeometry = new THREE.PlaneGeometry(20, 12);
        const screenMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.9,
        });

        panelMesh = new THREE.Mesh(screenGeometry, screenMaterial);
        // Position at center, facing the starting camera direction
        panelMesh.position.set(0, 8, 0);
        panelMesh.rotation.y = Math.PI;
        panelMesh.visible = false;
        scene.add(panelMesh);

        // Add some ambient glow around the screen area
        const screenLight = new THREE.PointLight(0x4488ff, 0.5, 10);
        screenLight.position.set(0, 8, 0);
        screenLight.visible = false;
        scene.add(screenLight);
        panelMesh.userData.screenLight = screenLight;
      }

      function loadModel(statusDisplay) {
        if (!THREE.GLTFLoader) {
          console.error("GLTFLoader not available");
          statusDisplay.innerText = "Error: GLTFLoader missing";
          createFallbackModel();
          return;
        }

        const loader = new THREE.GLTFLoader();

        statusDisplay.innerText = "Loading model...";

        loader.load(
          MODEL_URL,
          function (gltf) {
            gltf.scene.traverse(function (child) {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            // Position the model at the center
            gltf.scene.position.set(0, 0, 0);
            gltf.scene.scale.set(5, 5, 5);

            scene.add(gltf.scene);
            isModelLoaded = true;
            statusDisplay.innerText = "Ready! Click button to start";
            document
              .getElementById("start-button")
              .classList.remove("bg-sky-600");
            document
              .getElementById("start-button")
              .classList.add("bg-green-600");
            console.log("Model loaded successfully");
          },
          function (xhr) {
            const percent = (xhr.loaded / xhr.total) * 100 || 0;
            statusDisplay.innerText = `Loading: ${Math.round(percent)}%`;
          },
          function (error) {
            console.error("Error loading model:", error);
            statusDisplay.innerText = "Error loading model. Using fallback.";
            createFallbackModel();
          }
        );
      }

      function loadSecondModel() {
        if (!THREE.GLTFLoader) {
          console.error("GLTFLoader not available");
          createSecondFallbackModel();
          return;
        }

        const loader = new THREE.GLTFLoader();

        console.log("Loading second model...");

        loader.load(
          SECOND_MODEL_URL,
          function (gltf) {
            gltf.scene.traverse(function (child) {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            // Store reference to the second model
            secondModel = gltf.scene;

            // Apply position, rotation, and scale from configuration
            secondModel.position.copy(SECOND_MODEL_POSITION);
            secondModel.rotation.set(
              SECOND_MODEL_ROTATION.x,
              SECOND_MODEL_ROTATION.y,
              SECOND_MODEL_ROTATION.z
            );
            secondModel.scale.copy(SECOND_MODEL_SCALE);

            scene.add(secondModel);
            isSecondModelLoaded = true;

            console.log("Second model loaded successfully");
            console.log(
              `Position: (${SECOND_MODEL_POSITION.x}, ${SECOND_MODEL_POSITION.y}, ${SECOND_MODEL_POSITION.z})`
            );
            console.log(
              `Rotation: (${SECOND_MODEL_ROTATION.x}, ${SECOND_MODEL_ROTATION.y}, ${SECOND_MODEL_ROTATION.z})`
            );
            console.log(
              `Scale: (${SECOND_MODEL_SCALE.x}, ${SECOND_MODEL_SCALE.y}, ${SECOND_MODEL_SCALE.z})`
            );
          },
          function (xhr) {
            const percent = (xhr.loaded / xhr.total) * 100 || 0;
            console.log(`Loading second model: ${Math.round(percent)}%`);
          },
          function (error) {
            console.error("Error loading second model:", error);
            createSecondFallbackModel();
          }
        );
      }

      function createFallbackModel() {
        // Create a simple glowing cube as fallback
        const geometry = new THREE.BoxGeometry(6, 6, 6);
        const material = new THREE.MeshPhongMaterial({
          color: 0x00ff00,
          emissive: 0x004400,
        });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 3, 0);
        cube.castShadow = true;
        scene.add(cube);
        isModelLoaded = true;

        statusDisplay.innerText = "Ready! Click button to start";
        document.getElementById("start-button").classList.remove("bg-sky-600");
        document.getElementById("start-button").classList.add("bg-green-600");
      }

      function createSecondFallbackModel() {
        // Create a simple pyramid as fallback for the second model
        const geometry = new THREE.ConeGeometry(3, 5, 4);
        const material = new THREE.MeshPhongMaterial({
          color: 0xff6600,
          emissive: 0x442200,
        });
        const pyramid = new THREE.Mesh(geometry, material);

        // Apply position, rotation, and scale from configuration
        pyramid.position.copy(SECOND_MODEL_POSITION);
        pyramid.rotation.set(
          SECOND_MODEL_ROTATION.x,
          SECOND_MODEL_ROTATION.y,
          SECOND_MODEL_ROTATION.z
        );
        pyramid.scale.copy(SECOND_MODEL_SCALE);

        pyramid.castShadow = true;

        // Store reference to the second model
        secondModel = pyramid;
        scene.add(pyramid);
        isSecondModelLoaded = true;

        console.log("Second fallback model created");
      }

      function setupControls() {
        if (!THREE.PointerLockControls) {
          console.error("PointerLockControls not available");
          alert("PointerLockControls not supported in this browser");
          return;
        }

        controls = new THREE.PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        const overlay = document.getElementById("info-overlay");
        const startButton = document.getElementById("start-button");

        // Use button click instead of canvas click
        startButton.addEventListener("click", function () {
          if (isModelLoaded) {
            controls.lock();
            startButton.textContent = "Starting...";
          } else {
            alert("Please wait for the model to load completely");
          }
        });

        controls.addEventListener("lock", function () {
          console.log("Controls locked - entering first person mode");
          overlay.style.opacity = "0";
          setTimeout(() => {
            overlay.style.display = "none";
            isControlsEnabled = true;
          }, 500);
          canJump = true;

          // Hide mouse cursor when controls are locked
          document.body.style.cursor = "none";

          // Reset the flag when controls are locked
          isUnlockingForPanel = false;
        });

        controls.addEventListener("unlock", function () {
          console.log("Controls unlocked");

          // Only show overlay if we're not unlocking for panel
          if (!isUnlockingForPanel) {
            overlay.style.display = "flex";
            setTimeout(() => {
              overlay.style.opacity = "1";
            }, 10);
            startButton.textContent = "CLICK TO RESUME";
            startButton.classList.remove("bg-green-600");
            startButton.classList.add("bg-sky-600");
            resetMovement();
            isControlsEnabled = false;
          }

          // Show mouse cursor when controls are unlocked
          document.body.style.cursor = "auto";

          // Only close panel if we're not unlocking for panel
          if (isPanelOpen && !isUnlockingForPanel) {
            closePanel();
          }

          // Reset the flag
          isUnlockingForPanel = false;
        });

        // Keyboard controls
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);

        // ESC key to unlock
        document.addEventListener("keydown", function (event) {
          if (event.code === "Escape") {
            if (isPanelOpen) {
              closePanel();
            } else if (controls.isLocked) {
              controls.unlock();
            }
          }
        });
      }

      function setupPanel() {
        const closeButton = document.getElementById("panel-close");
        const panel = document.getElementById("website-panel");

        closeButton.addEventListener("click", function () {
          closePanel();
        });

        // Load the website when panel opens
        document.addEventListener("keydown", function (event) {
          if (event.code === "KeyE" && isControlsEnabled && !isPanelOpen) {
            const distance = controls
              .getObject()
              .position.distanceTo(INTERACT_POSITION);
            if (distance <= INTERACT_RADIUS) {
              // Set flag and free the mouse when opening panel
              isUnlockingForPanel = true;
              controls.unlock();
              openPanel();
            }
          }
        });
      }

      function openPanel() {
        if (isPanelOpen) return;

        isPanelOpen = true;
        const panel = document.getElementById("website-panel");
        const frame = document.getElementById("panel-frame");

        console.log("Opening panel...");

        // Use direct style manipulation to ensure proper positioning
        panel.style.display = "flex";
        panel.style.position = "fixed";
        panel.style.top = "50%";
        panel.style.left = "50%";
        panel.style.transform = "translate(-50%, -50%) scale(0.8)";
        panel.style.width = "80vw";
        panel.style.height = "80vh";
        panel.style.zIndex = "1000";
        panel.style.opacity = "0";

        // Force reflow
        panel.offsetHeight;

        // Animate to full size
        setTimeout(() => {
          panel.style.transform = "translate(-50%, -50%) scale(1)";
          panel.style.opacity = "1";
        }, 10);

        // Load the website
        frame.src = TARGET_WEBSITE;

        // Show the 3D screen at the CENTER
        if (panelMesh) {
          panelMesh.visible = true;
          // Create a glowing screen effect
          const screenTexture = new THREE.MeshBasicMaterial({
            color: 0x88aaff,
            transparent: true,
            opacity: 0.8,
          });
          panelMesh.material = screenTexture;

          // Turn on the screen light
          if (panelMesh.userData.screenLight) {
            panelMesh.userData.screenLight.visible = true;
          }
        }

        console.log("Panel opened at center");
      }

      function closePanel() {
        if (!isPanelOpen) return;

        isPanelOpen = false;
        const panel = document.getElementById("website-panel");
        const frame = document.getElementById("panel-frame");

        console.log("Closing panel...");

        // Animate out
        panel.style.transform = "translate(-50%, -50%) scale(0.8)";
        panel.style.opacity = "0";

        setTimeout(() => {
          panel.style.display = "none";

          // Lock pointer again after panel closes
          if (isControlsEnabled && !controls.isLocked) {
            controls.lock();
          }
        }, 500);

        // Unload the website
        frame.src = "about:blank";

        // Hide the 3D screen
        if (panelMesh) {
          panelMesh.visible = false;

          // Turn off the screen light
          if (panelMesh.userData.screenLight) {
            panelMesh.userData.screenLight.visible = false;
          }
        }

        console.log("Panel closed");
      }

      function onKeyDown(event) {
        if (!isControlsEnabled) return;

        // REVERSED CONTROLS:
        switch (event.code) {
          case "KeyW":
          case "ArrowUp":
            moveBackward = true;
            break; // REVERSED
          case "KeyD":
          case "ArrowRight":
            moveRight = true;
            break; // REVERSED
          case "KeyS":
          case "ArrowDown":
            moveForward = true;
            break; // REVERSED
          case "KeyA":
          case "ArrowLeft":
            moveLeft = true;
            break; // REVERSED
          case "Space":
            if (canJump) {
              velocity.y = JUMP_VELOCITY;
              canJump = false;
            }
            break;
          case "KeyE":
            keyEPressed = true;
            break;
          case "KeyB":
            // Transition to another website when B is pressed
            transitionToWebsite();
            break;
        }
      }

      function onKeyUp(event) {
        if (!isControlsEnabled) return;

        // REVERSED CONTROLS:
        switch (event.code) {
          case "KeyW":
          case "ArrowUp":
            moveBackward = false;
            break; // REVERSED
          case "KeyD":
          case "ArrowRight":
            moveRight = false;
            break; // REVERSED
          case "KeyS":
          case "ArrowDown":
            moveForward = false;
            break; // REVERSED
          case "KeyA":
          case "ArrowLeft":
            moveLeft = false;
            break; // REVERSED
          case "KeyE":
            keyEPressed = false;
            break;
        }
      }

      function resetMovement() {
        moveForward = moveBackward = moveLeft = moveRight = false;
        velocity.set(0, 0, 0);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        if (isControlsEnabled && controls.isLocked) {
          const time = performance.now();
          const delta = Math.min((time - prevTime) / 1000, 0.1);

          // Apply gravity
          velocity.y -= GRAVITY * delta;

          // Calculate movement direction with REVERSED controls
          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveLeft) - Number(moveRight); // REVERSED
          direction.normalize();

          // Apply movement (only when keys are pressed)
          if (moveForward || moveBackward) {
            velocity.z = -direction.z * MOVEMENT_SPEED;
          } else {
            velocity.z = 0;
          }

          if (moveLeft || moveRight) {
            velocity.x = -direction.x * MOVEMENT_SPEED;
          } else {
            velocity.x = 0;
          }

          // Apply velocity to controls
          controls.moveRight(velocity.x * delta);
          controls.moveForward(velocity.z * delta);

          // Apply vertical movement
          const player = controls.getObject();
          player.position.y += velocity.y * delta;

          // Ground collision
          if (player.position.y < PLAYER_HEIGHT) {
            velocity.y = 0;
            player.position.y = PLAYER_HEIGHT;
            canJump = true;
          }

          // Check interaction - now with the second model position
          const distance = player.position.distanceTo(INTERACT_POSITION);
          const prompt = document.getElementById("interact-prompt");

          if (distance <= INTERACT_RADIUS && !isPanelOpen) {
            prompt.style.display = "block";
            if (keyEPressed) {
              // Set flag and free the mouse when opening panel
              isUnlockingForPanel = true;
              controls.unlock();
              openPanel();
              keyEPressed = false;
            }
          } else {
            prompt.style.display = "none";
          }

          prevTime = time;
        }

        renderer.render(scene, camera);
      }

      // Function to transition to another website when B is pressed
      function transitionToWebsite() {
        console.log("B key pressed - transitioning to website");
        
        // Create a confirmation dialog
        const confirmed = confirm("Are you sure you want to exit the simulation and Enter The Lunar Simulation?");
        
        if (confirmed) {
          // Unlock controls if they're locked
          if (controls && controls.isLocked) {
            controls.unlock();
          }
          
          // Close any open panels
          if (isPanelOpen) {
            closePanel();
          }
          
          // Wait a moment for cleanup then redirect
          setTimeout(() => {
            window.location.href = B_KEY_TRANSITION_URL;
          }, 500);
        }
      }

      // Initialize when everything is loaded
      window.addEventListener("load", function () {
        if (window.THREE) {
          console.log("THREE.js loaded successfully");
          init();
        } else {
          console.error("THREE.js failed to load");
          document.getElementById("loading-status").innerText =
            "Error: THREE.js failed to load";
        }
      });

      // // Simple user ID
      // window.addEventListener('load', function() {
      //     const userId = 'user-' + Math.random().toString(36).substr(2, 9);
      //     document.getElementById('user-id-display').innerText = `User ID: ${userId}`;
      // });
    </script>
  </body>
</html>